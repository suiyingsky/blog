(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{464:function(e,a,t){"use strict";t.r(a);var n=t(29),r=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"java8-新特性教程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java8-新特性教程"}},[e._v("#")]),e._v(" Java8 新特性教程")]),e._v(" "),t("p",[e._v("能够熟练掌握和应用 Java8 的各种特性，使其成为在工作中的一门利器。废话不多说，让我们一起开启 Java8 新特性之旅吧！")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"接口内允许添加默认实现的方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口内允许添加默认实现的方法"}},[e._v("#")]),e._v(" 接口内允许添加默认实现的方法")]),e._v(" "),t("p",[e._v("Java 8 允许我们通过 "),t("code",[e._v("default")]),e._v(" 关键字对接口中定义的抽象方法提供一个默认的实现。")]),e._v(" "),t("p",[e._v("请看下面示例代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 定义一个公式接口\ninterface Formula {\n    // 计算\n    double calculate(int a);\n\n    // 求平方根\n    default double sqrt(int a) {\n        return Math.sqrt(a);\n    }\n}\n")])])]),t("p",[e._v("在上面这个接口中，我们除了定义了一个抽象方法 "),t("code",[e._v("calculate")]),e._v("，还定义了一个带有默认实现的方法 "),t("code",[e._v("sqrt")]),e._v("。 我们在实现这个接口时，可以只需要实现 "),t("code",[e._v("calculate")]),e._v(" 方法，默认方法 "),t("code",[e._v("sqrt")]),e._v(" 可以直接调用即可，也就是说我们可以不必强制实现 "),t("code",[e._v("sqrt")]),e._v(" 方法。")]),e._v(" "),t("blockquote",[t("p",[e._v("补充：通过 "),t("code",[e._v("default")]),e._v(" 关键字这个新特性，可以非常方便地对之前的接口做拓展，而此接口的实现类不必做任何改动。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Formula formula = new Formula() {\n    @Override\n    public double calculate(int a) {\n        return sqrt(a * 100);\n    }\n};\n\nformula.calculate(100);     // 100.0\nformula.sqrt(16);           // 4.0\n")])])]),t("p",[e._v("上面通过匿名对象实现了 "),t("code",[e._v("Formula")]),e._v(" 接口。但是即使是这样，我们为了完成一个 "),t("code",[e._v("sqrt(a * 100)")]),e._v(" 简单计算，就写了 6 行代码，很是冗余。")]),e._v(" "),t("h2",{attrs:{id:"lambda-表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lambda-表达式"}},[e._v("#")]),e._v(" Lambda 表达式")]),e._v(" "),t("p",[e._v("在学习 "),t("code",[e._v("Lambda")]),e._v(" 表达式之前，我们先来看一段老版本的示例代码，其对一个含有字符串的集合进行排序：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('List<String> names = Arrays.asList("peter", "anna", "mike", "xenia");\n\nCollections.sort(names, new Comparator<String>() {\n    @Override\n    public int compare(String a, String b) {\n        return b.compareTo(a);\n    }\n});\n')])])]),t("p",[t("code",[e._v("Collections")]),e._v(" 工具类提供了静态方法 "),t("code",[e._v("sort")]),e._v(" 方法，入参是一个 "),t("code",[e._v("List")]),e._v(" 集合，和一个 "),t("code",[e._v("Comparator")]),e._v(" 比较器，以便对给定的 "),t("code",[e._v("List")]),e._v(" 集合进行 排序。上面的示例代码创建了一个匿名内部类作为入参，这种类似的操作在我们日常的工作中随处可见。")]),e._v(" "),t("p",[e._v("Java 8 中不再推荐这种写法，而是推荐使用 Lambda 表达：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Collections.sort(names, (String a, String b) -> {\n    return b.compareTo(a);\n});\n")])])]),t("p",[e._v("正如你看到的，上面这段代码变得简短很多而且易于阅读。但是我们还可以再精炼一点：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Collections.sort(names, (String a, String b) -> b.compareTo(a));\n")])])]),t("p",[e._v("对于只包含一行方法的代码块，我们可以省略大括号，直接 "),t("code",[e._v("return")]),e._v(" 关键代码即可。追求极致，我们还可以让它再短点：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("names.sort((a, b) -> b.compareTo(a));\n")])])]),t("p",[t("code",[e._v("List")]),e._v(" 集合现在已经添加了 "),t("code",[e._v("sort")]),e._v(" 方法。而且 Java 编译器能够根据"),t("strong",[e._v("类型推断机制")]),e._v("判断出参数类型，这样，你连入参的类型都可以省略啦，怎么样，是不是感觉很强大呢！")]),e._v(" "),t("h2",{attrs:{id:"函数式接口-functional-interface"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数式接口-functional-interface"}},[e._v("#")]),e._v(" 函数式接口 Functional Interface")]),e._v(" "),t("p",[e._v("抛出一个疑问：在我们书写一段 Lambda 表达式后（比如上一章节中匿名内部类的 Lambda 表达式缩写形式），Java 编译器是如何进行类型推断的，它又是怎么知道重写的哪个方法的？")]),e._v(" "),t("p",[e._v("需要说明的是，不是每个接口都可以缩写成 Lambda 表达式。只有那些函数式接口（Functional Interface）才能缩写成 Lambda 表示式。")]),e._v(" "),t("p",[e._v("那么什么是函数式接口（Functional Interface）呢？")]),e._v(" "),t("p",[e._v("所谓函数式接口（Functional Interface）就是只包含一个抽象方法的声明。针对该接口类型的所有 Lambda 表达式都会与这个抽象方法匹配。")]),e._v(" "),t("blockquote",[t("p",[e._v("注意：你可能会有疑问，Java 8 中不是允许通过 defualt 关键字来为接口添加默认方法吗？那它算不算抽象方法呢？答案是：不算。因此，你可以毫无顾忌的添加默认方法，它并不违反函数式接口（Functional Interface）的定义。")])]),e._v(" "),t("p",[e._v("总结一下：只要接口中仅仅包含一个抽象方法，我们就可以将其改写为 Lambda 表达式。为了保证一个接口明确的被定义为一个函数式接口（Functional Interface），我们需要为该接口添加注解："),t("code",[e._v("@FunctionalInterface")]),e._v("。这样，一旦你添加了第二个抽象方法，编译器会立刻抛出错误提示。")]),e._v(" "),t("p",[e._v("示例代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("@FunctionalInterface\ninterface Converter<F, T> {\n    T convert(F from);\n}\n")])])]),t("p",[e._v("示例代码 2：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('Converter<String, Integer> converter = (from) -> Integer.valueOf(from);\nInteger converted = converter.convert("123");\nSystem.out.println(converted);    // 123\n')])])]),t("blockquote",[t("p",[e._v("注意：上面的示例代码，即使去掉 "),t("code",[e._v("@FunctionalInterface")]),e._v(" 也是好使的，它仅仅是一种约束而已。")])]),e._v(" "),t("h2",{attrs:{id:"便捷的引用类的构造器及方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#便捷的引用类的构造器及方法"}},[e._v("#")]),e._v(" 便捷的引用类的构造器及方法")]),e._v(" "),t("p",[e._v("小伙伴们，还记得上一个章节这段示例代码么：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('@FunctionalInterface\ninterface Converter<F, T> {\n    T convert(F from);\n}\n\n\nConverter<String, Integer> converter = (from) -> Integer.valueOf(from);\nInteger converted = converter.convert("123");\nSystem.out.println(converted);    // 123\n')])])]),t("p",[e._v("上面这段代码，通过 Java 8 的新特性，进一步简化上面的代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('Converter<String, Integer> converter = Integer::valueOf;\nInteger converted = converter.convert("123");\nSystem.out.println(converted);   // 123\n')])])]),t("p",[e._v("Java 8 中允许你通过 "),t("code",[e._v("::")]),e._v(" 关键字来引用类的方法或构造器。上面的代码简单的示例了如何引用静态方法，当然，除了静态方法，我们还可以引用普通方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('class Something {\n    String startsWith(String s) {\n        return String.valueOf(s.charAt(0));\n    }\n}\n\n\nSomething something = new Something();\nConverter<String, String> converter = something::startsWith;\nString converted = converter.convert("Java");\nSystem.out.println(converted);    // "J"\n')])])]),t("p",[e._v("接下来，我们再来看看如何通过 "),t("code",[e._v("::")]),e._v(" 关键字来引用类的构造器。首先，我们先来定义一个示例类，在类中声明两个构造器：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("class Person {\n    String firstName;\n    String lastName;\n\n    Person() {}\n\n    Person(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n}\n")])])]),t("p",[e._v("然后，我们再定义一个工厂接口，用来生成 "),t("code",[e._v("Person")]),e._v(" 类：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// Person 工厂\ninterface PersonFactory<P extends Person> {\n    P create(String firstName, String lastName);\n}\n")])])]),t("p",[e._v("我们可以通过 "),t("code",[e._v("::")]),e._v(" 关键字来引用 "),t("code",[e._v("Person")]),e._v(" 类的构造器，来代替手动去实现这个工厂接口：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 直接引用 Person 构造器\nPersonFactory<Person> personFactory = Person::new;\nPerson person = personFactory.create("Peter", "Parker");\n')])])]),t("p",[t("code",[e._v("Person::new")]),e._v(" 这段代码，能够直接引用 "),t("code",[e._v("Person")]),e._v(" 类的构造器。然后 Java 编译器能够根据上下文选中正确的构造器去实现 "),t("code",[e._v("PersonFactory.create")]),e._v(" 方法。")]),e._v(" "),t("h2",{attrs:{id:"lambda-访问外部变量及接口默认方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lambda-访问外部变量及接口默认方法"}},[e._v("#")]),e._v(" Lambda 访问外部变量及接口默认方法")]),e._v(" "),t("p",[e._v("在本章节中，我们将会讨论如何在 lambda 表达式中访问外部变量（包括：局部变量，成员变量，静态变量，接口的默认方法.），它与匿名内部类访问外部变量很相似。")]),e._v(" "),t("h3",{attrs:{id:"访问局部变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问局部变量"}},[e._v("#")]),e._v(" 访问局部变量")]),e._v(" "),t("p",[e._v("在 Lambda 表达式中，我们可以访问外部的 "),t("code",[e._v("final")]),e._v(" 类型变量，如下面的示例代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 转换器\n@FunctionalInterface\ninterface Converter<F, T> {\n    T convert(F from);\n}\n\n\nfinal int num = 1;\nConverter<Integer, String> stringConverter =\n        (from) -> String.valueOf(from + num);\n\nstringConverter.convert(2);     // 3\n")])])]),t("p",[e._v("与匿名内部类不同的是，我们不必显式声明 "),t("code",[e._v("num")]),e._v(" 变量为 "),t("code",[e._v("final")]),e._v(" 类型，下面这段代码同样有效：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("int num = 1;\nConverter<Integer, String> stringConverter =\n        (from) -> String.valueOf(from + num);\n\nstringConverter.convert(2);     // 3\n")])])]),t("p",[e._v("但是 "),t("code",[e._v("num")]),e._v(" 变量必须为隐式的 "),t("code",[e._v("final")]),e._v(" 类型，何为隐式的 "),t("code",[e._v("final")]),e._v(" 呢？就是说到编译期为止，"),t("code",[e._v("num")]),e._v(" 对象是不能被改变的，如下面这段代码，就不能被编译通过：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("int num = 1;\nConverter<Integer, String> stringConverter =\n        (from) -> String.valueOf(from + num);\nnum = 3;\n")])])]),t("p",[e._v("在 lambda 表达式内部改变 "),t("code",[e._v("num")]),e._v(" 值同样编译不通过，需要注意, 比如下面的示例代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("int num = 1;\nConverter<Integer, String> converter = (from) -> {\n\tString value = String.valueOf(from + num);\n\tnum = 3;\n\treturn value;\n};\n")])])]),t("h3",{attrs:{id:"访问成员变量和静态变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问成员变量和静态变量"}},[e._v("#")]),e._v(" 访问成员变量和静态变量")]),e._v(" "),t("p",[e._v("上一章节中，了解了如何在 Lambda 表达式中访问局部变量。与局部变量相比，在 Lambda 表达式中对成员变量和静态变量拥有读写权限：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    @FunctionalInterface\n    interface Converter<F, T> {\n        T convert(F from);\n    }\n\n\nclass Lambda4 {\n        // 静态变量\n        static int outerStaticNum;\n        // 成员变量\n        int outerNum;\n\n        void testScopes() {\n            Converter<Integer, String> stringConverter1 = (from) -> {\n                // 对成员变量赋值\n                outerNum = 23;\n                return String.valueOf(from);\n            };\n\n            Converter<Integer, String> stringConverter2 = (from) -> {\n                // 对静态变量赋值\n                outerStaticNum = 72;\n                return String.valueOf(from);\n            };\n        }\n    }\n")])])]),t("h3",{attrs:{id:"访问接口的默认方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问接口的默认方法"}},[e._v("#")]),e._v(" 访问接口的默认方法")]),e._v(" "),t("p",[e._v("还记得第一章节中定义的那个 "),t("code",[e._v("Formula")]),e._v(" (公式) 接口吗？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("@FunctionalInterface\ninterface Formula {\n\t// 计算\n\tdouble calculate(int a);\n\n\t// 求平方根\n\tdefault double sqrt(int a) {\n\t\treturn Math.sqrt(a);\n\t}\n}\n")])])]),t("p",[e._v("当时，我们在接口中定义了一个带有默认实现的 "),t("code",[e._v("sqrt")]),e._v(" 求平方根方法，在匿名内部类中我们可以很方便的访问此方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Formula formula = new Formula() {\n\t@Override\n\tpublic double calculate(int a) {\n\t\treturn sqrt(a * 100);\n\t}\n};\n")])])]),t("p",[e._v("但是在 lambda 表达式中可不行：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Formula formula = (a) -> sqrt(a * 100);\n")])])]),t("p",[e._v("带有默认实现的接口方法，是"),t("strong",[e._v("不能")]),e._v("在 lambda 表达式中访问的，上面这段代码将无法被编译通过。")]),e._v(" "),t("h2",{attrs:{id:"内置的函数式接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内置的函数式接口"}},[e._v("#")]),e._v(" 内置的函数式接口")]),e._v(" "),t("p",[e._v("JDK 1.8 API 包含了很多内置的函数式接口。其中就包括我们在老版本中经常见到的 Comparator 和 Runnable，Java 8 为他们都添加了 @FunctionalInterface 注解，以用来支持 Lambda 表达式。")]),e._v(" "),t("p",[e._v("值得一提的是，除了 Comparator 和 Runnable 外，还有一些新的函数式接口，它们很多都借鉴于知名的 "),t("a",{attrs:{href:"https://github.com/google/guava",target:"_blank",rel:"noopener noreferrer"}},[e._v("Google Guava"),t("OutboundLink")],1),e._v(" 库。")]),e._v(" "),t("p",[e._v("对于它们，即使你已经非常熟悉了，还是最好了解一下的：")]),e._v(" "),t("h3",{attrs:{id:"predicate-断言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#predicate-断言"}},[e._v("#")]),e._v(" Predicate 断言")]),e._v(" "),t("p",[t("code",[e._v("Predicate")]),e._v(" 是一个可以指定入参类型，并返回 boolean 值的函数式接口。它内部提供了一些带有默认实现的方法，可以 被用来组合一个复杂的逻辑判断（"),t("code",[e._v("and")]),e._v(", "),t("code",[e._v("or")]),e._v(", "),t("code",[e._v("negate")]),e._v("）：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('Predicate<String> predicate = (s) -> s.length() > 0;\n\npredicate.test("foo");              // true\npredicate.negate().test("foo");     // false\n\nPredicate<Boolean> nonNull = Objects::nonNull;\nPredicate<Boolean> isNull = Objects::isNull;\n\nPredicate<String> isEmpty = String::isEmpty;\nPredicate<String> isNotEmpty = isEmpty.negate();\n')])])]),t("h3",{attrs:{id:"function"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#function"}},[e._v("#")]),e._v(" Function")]),e._v(" "),t("p",[t("code",[e._v("Function")]),e._v(" 函数式接口的作用是，我们可以为其提供一个原料，他给生产一个最终的产品。通过它提供的默认方法，组合,链行处理("),t("code",[e._v("compose")]),e._v(", "),t("code",[e._v("andThen")]),e._v(")：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('Function<String, Integer> toInteger = Integer::valueOf;\nFunction<String, String> backToString = toInteger.andThen(String::valueOf);\n\nbackToString.apply("123");     // "123"\n')])])]),t("h3",{attrs:{id:"supplier-生产者"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#supplier-生产者"}},[e._v("#")]),e._v(" Supplier 生产者")]),e._v(" "),t("p",[t("code",[e._v("Supplier")]),e._v(" 与 "),t("code",[e._v("Function")]),e._v(" 不同，它不接受入参，直接为我们生产一个指定的结果，有点像生产者模式：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("class Person {\n    String firstName;\n    String lastName;\n\n    Person() {}\n\n    Person(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n}\n\n\nSupplier<Person> personSupplier = Person::new;\npersonSupplier.get();   // new Person\n")])])]),t("h3",{attrs:{id:"consumer-消费者"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#consumer-消费者"}},[e._v("#")]),e._v(" Consumer 消费者")]),e._v(" "),t("p",[e._v("对于 "),t("code",[e._v("Consumer")]),e._v("，我们需要提供入参，用来被消费，如下面这段示例代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('class Person {\n    String firstName;\n    String lastName;\n\n    Person() {}\n\n    Person(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n}\n\n\nConsumer<Person> greeter = (p) -> System.out.println("Hello, " + p.firstName);\ngreeter.accept(new Person("Luke", "Skywalker"));\n')])])]),t("h3",{attrs:{id:"comparator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#comparator"}},[e._v("#")]),e._v(" Comparator")]),e._v(" "),t("p",[t("code",[e._v("Comparator")]),e._v(" 在 Java 8 之前是使用比较普遍的。Java 8 中除了将其升级成了函数式接口，还为它拓展了一些默认方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('Comparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);\n\nPerson p1 = new Person("John", "Doe");\nPerson p2 = new Person("Alice", "Wonderland");\n\ncomparator.compare(p1, p2);             // > 0\ncomparator.reversed().compare(p1, p2);  // < 0\n')])])]),t("h2",{attrs:{id:"optional"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#optional"}},[e._v("#")]),e._v(" Optional")]),e._v(" "),t("p",[e._v("首先，"),t("code",[e._v("Optional")]),e._v(" 它不是一个函数式接口，设计它的目的是为了防止空指针异常（"),t("code",[e._v("NullPointerException")]),e._v("），要知道在 Java 编程中， 空指针异常可是臭名昭著的。")]),e._v(" "),t("p",[e._v("让我们来快速了解一下 "),t("code",[e._v("Optional")]),e._v(" 要如何使用！你可以将 "),t("code",[e._v("Optional")]),e._v(" 看做是包装对象（可能是 "),t("code",[e._v("null")]),e._v(", 也有可能非 "),t("code",[e._v("null")]),e._v("）的容器。当你定义了 一个方法，这个方法返回的对象可能是空，也有可能非空的时候，你就可以考虑用 "),t("code",[e._v("Optional")]),e._v(" 来包装它，这也是在 Java 8 被推荐使用的做法。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('Optional<String> optional = Optional.of("bam");\n\noptional.isPresent();           // true\noptional.get();                 // "bam"\noptional.orElse("fallback");    // "bam"\n\noptional.ifPresent((s) -> System.out.println(s.charAt(0)));     // "b"\n')])])]),t("h2",{attrs:{id:"stream-流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#stream-流"}},[e._v("#")]),e._v(" Stream 流")]),e._v(" "),t("p",[e._v("这一章节，我们开始步入学习 "),t("code",[e._v("Stream")]),e._v(" 流。")]),e._v(" "),t("p",[t("em",[e._v("什么是 "),t("code",[e._v("Stream")]),e._v(" 流？")])]),e._v(" "),t("p",[e._v("简单来说，我们可以使用 "),t("code",[e._v("java.util.Stream")]),e._v(" 对一个包含一个或多个元素的集合做各种操作。这些操作可能是 "),t("em",[e._v("中间操作")]),e._v(" 亦或是 "),t("em",[e._v("终端操作")]),e._v("。 终端操作会返回一个结果，而中间操作会返回一个 "),t("code",[e._v("Stream")]),e._v(" 流。")]),e._v(" "),t("p",[e._v("需要注意的是，你只能对实现了 "),t("code",[e._v("java.util.Collection")]),e._v(" 接口的类做流的操作。")]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("Map")]),e._v(" 不支持 "),t("code",[e._v("Stream")]),e._v(" 流。")])]),e._v(" "),t("p",[t("code",[e._v("Stream")]),e._v(" 流支持同步执行，也支持并发执行。")]),e._v(" "),t("p",[e._v("让我们开始步入学习的旅程吧！Go !")]),e._v(" "),t("h3",{attrs:{id:"filter-过滤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#filter-过滤"}},[e._v("#")]),e._v(" Filter 过滤")]),e._v(" "),t("p",[e._v("首先，我们创建一个 "),t("code",[e._v("List")]),e._v(" 集合：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('List<String> stringCollection = new ArrayList<>();\nstringCollection.add("ddd2");\nstringCollection.add("aaa2");\nstringCollection.add("bbb1");\nstringCollection.add("aaa1");\nstringCollection.add("bbb3");\nstringCollection.add("ccc");\nstringCollection.add("bbb2");\nstringCollection.add("ddd1");\n')])])]),t("p",[t("code",[e._v("Filter")]),e._v(" 的入参是一个 "),t("code",[e._v("Predicate")]),e._v(", 上面已经说到，"),t("code",[e._v("Predicate")]),e._v(" 是一个断言的中间操作，它能够帮我们筛选出我们需要的集合元素。它的返参同样 是一个 "),t("code",[e._v("Stream")]),e._v(" 流，我们可以通过 "),t("code",[e._v("foreach")]),e._v(" 终端操作，来打印被筛选的元素：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('stringCollection\n    .stream()\n    .filter((s) -> s.startsWith("a"))\n    .forEach(System.out::println);\n\n// "aaa2", "aaa1"\n')])])]),t("blockquote",[t("p",[e._v("注意："),t("code",[e._v("foreach")]),e._v(" 是一个终端操作，它的返参是 "),t("code",[e._v("void")]),e._v(", 我们无法对其再次进行流操作。")])]),e._v(" "),t("h3",{attrs:{id:"sorted-排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sorted-排序"}},[e._v("#")]),e._v(" Sorted 排序")]),e._v(" "),t("p",[t("code",[e._v("Sorted")]),e._v(" 同样是一个中间操作，它的返参是一个 "),t("code",[e._v("Stream")]),e._v(" 流。另外，我们可以传入一个 "),t("code",[e._v("Comparator")]),e._v(" 用来自定义排序，如果不传，则使用默认的排序规则。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('stringCollection\n    .stream()\n    .sorted()\n    .filter((s) -> s.startsWith("a"))\n    .forEach(System.out::println);\n\n// "aaa1", "aaa2"\n')])])]),t("p",[e._v("需要注意，"),t("code",[e._v("sorted")]),e._v(" 不会对 "),t("code",[e._v("stringCollection")]),e._v(" 做出任何改变，"),t("code",[e._v("stringCollection")]),e._v(" 还是原有的那些个元素，且顺序不变：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("System.out.println(stringCollection);\n// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1\n")])])]),t("h3",{attrs:{id:"map-转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map-转换"}},[e._v("#")]),e._v(" Map 转换")]),e._v(" "),t("p",[e._v("中间操作 "),t("code",[e._v("Map")]),e._v(" 能够帮助我们将 "),t("code",[e._v("List")]),e._v(" 中的每一个元素做功能处理。例如下面的示例，通过 "),t("code",[e._v("map")]),e._v(" 我们将每一个 "),t("code",[e._v("string")]),e._v(" 转成大写：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('stringCollection\n    .stream()\n    .map(String::toUpperCase)\n    .sorted((a, b) -> b.compareTo(a))\n    .forEach(System.out::println);\n\n// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"\n')])])]),t("p",[e._v("另外，我们还可以做对象之间的转换，业务中比较常用的是将 "),t("code",[e._v("DO")]),e._v("（数据库对象） 转换成 "),t("code",[e._v("BO")]),e._v("（业务对象） 。")]),e._v(" "),t("h3",{attrs:{id:"match-匹配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#match-匹配"}},[e._v("#")]),e._v(" Match 匹配")]),e._v(" "),t("p",[e._v("顾名思义，"),t("code",[e._v("match")]),e._v(" 用来做匹配操作，它的返回值是一个 "),t("code",[e._v("boolean")]),e._v(" 类型。通过 "),t("code",[e._v("match")]),e._v(", 我们可以方便的验证一个 "),t("code",[e._v("list")]),e._v(" 中是否存在某个类型的元素。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 验证 list 中 string 是否有以 a 开头的, 匹配到第一个，即返回 true\nboolean anyStartsWithA =\n    stringCollection\n        .stream()\n        .anyMatch((s) -> s.startsWith("a"));\n\nSystem.out.println(anyStartsWithA);      // true\n\n// 验证 list 中 string 是否都是以 a 开头的\nboolean allStartsWithA =\n    stringCollection\n        .stream()\n        .allMatch((s) -> s.startsWith("a"));\n\nSystem.out.println(allStartsWithA);      // false\n\n// 验证 list 中 string 是否都不是以 z 开头的,\nboolean noneStartsWithZ =\n    stringCollection\n        .stream()\n        .noneMatch((s) -> s.startsWith("z"));\n\nSystem.out.println(noneStartsWithZ);      // true\n')])])]),t("h3",{attrs:{id:"count-计数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#count-计数"}},[e._v("#")]),e._v(" Count 计数")]),e._v(" "),t("p",[t("code",[e._v("count")]),e._v(" 是一个终端操作，它能够统计 "),t("code",[e._v("stream")]),e._v(" 流中的元素总数，返回值是 "),t("code",[e._v("long")]),e._v(" 类型。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 先对 list 中字符串开头为 b 进行过滤，让后统计数量\nlong startsWithB =\n    stringCollection\n        .stream()\n        .filter((s) -> s.startsWith("b"))\n        .count();\n\nSystem.out.println(startsWithB);    // 3\n')])])]),t("h3",{attrs:{id:"reduce"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reduce"}},[e._v("#")]),e._v(" Reduce")]),e._v(" "),t("p",[t("code",[e._v("Reduce")]),e._v(" 中文翻译为："),t("em",[e._v("减少、缩小")]),e._v("。通过入参的 "),t("code",[e._v("Function")]),e._v("，我们能够将 "),t("code",[e._v("list")]),e._v(" 归约成一个值。它的返回类型是 "),t("code",[e._v("Optional")]),e._v(" 类型。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('Optional<String> reduced =\n    stringCollection\n        .stream()\n        .sorted()\n        .reduce((s1, s2) -> s1 + "#" + s2);\n\nreduced.ifPresent(System.out::println);\n// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"\n')])])]),t("h2",{attrs:{id:"parallel-streams-并行流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#parallel-streams-并行流"}},[e._v("#")]),e._v(" Parallel-Streams 并行流")]),e._v(" "),t("p",[e._v("前面章节我们说过，"),t("code",[e._v("stream")]),e._v(" 流是支持"),t("strong",[e._v("顺序")]),e._v("和"),t("strong",[e._v("并行")]),e._v("的。顺序流操作是单线程操作，而并行流是通过多线程来处理的，能够充分利用物理机 多核 CPU 的优势，同时处理速度更快。")]),e._v(" "),t("p",[e._v("首先，我们创建一个包含 1000000 UUID list 集合。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("int max = 1000000;\nList<String> values = new ArrayList<>(max);\nfor (int i = 0; i < max; i++) {\n    UUID uuid = UUID.randomUUID();\n    values.add(uuid.toString());\n}\n")])])]),t("p",[e._v("分别通过顺序流和并行流，对这个 list 进行排序，测算耗时:")]),e._v(" "),t("h3",{attrs:{id:"顺序流排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#顺序流排序"}},[e._v("#")]),e._v(" 顺序流排序")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 纳秒\nlong t0 = System.nanoTime();\n\nlong count = values.stream().sorted().count();\nSystem.out.println(count);\n\nlong t1 = System.nanoTime();\n\n// 纳秒转微秒\nlong millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\nSystem.out.println(String.format("顺序流排序耗时: %d ms", millis));\n\n// 顺序流排序耗时: 899 ms\n')])])]),t("h3",{attrs:{id:"并行流排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并行流排序"}},[e._v("#")]),e._v(" 并行流排序")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 纳秒\nlong t0 = System.nanoTime();\n\nlong count = values.parallelStream().sorted().count();\nSystem.out.println(count);\n\nlong t1 = System.nanoTime();\n\n// 纳秒转微秒\nlong millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);\nSystem.out.println(String.format("并行流排序耗时: %d ms", millis));\n\n// 并行流排序耗时: 472 ms\n')])])]),t("p",[e._v("正如你所见，同样的逻辑处理，通过并行流，我们的性能提升了近 "),t("strong",[e._v("50%")]),e._v("。完成这一切，我们需要做的仅仅是将 "),t("code",[e._v("stream")]),e._v(" 改成了 "),t("code",[e._v("parallelStream")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"map-集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map-集合"}},[e._v("#")]),e._v(" Map 集合")]),e._v(" "),t("p",[e._v("前面已经提到过 "),t("code",[e._v("Map")]),e._v(" 是不支持 "),t("code",[e._v("Stream")]),e._v(" 流的，因为 "),t("code",[e._v("Map")]),e._v(" 接口并没有像 "),t("code",[e._v("Collection")]),e._v(" 接口那样，定义了 "),t("code",[e._v("stream()")]),e._v(" 方法。但是，我们可以对其 "),t("code",[e._v("key")]),e._v(", "),t("code",[e._v("values")]),e._v(", "),t("code",[e._v("entry")]),e._v(" 使用 流操作，如 "),t("code",[e._v("map.keySet().stream()")]),e._v(", "),t("code",[e._v("map.values().stream()")]),e._v(" 和 "),t("code",[e._v("map.entrySet().stream()")]),e._v(".")]),e._v(" "),t("p",[e._v("另外, JDK 8 中对 "),t("code",[e._v("map")]),e._v(" 提供了一些其他新特性:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('Map<Integer, String> map = new HashMap<>();\n\nfor (int i = 0; i < 10; i++) {\n    // 与老版不同的是，putIfAbent() 方法在 put 之前，\n    // 会判断 key 是否已经存在，存在则直接返回 value, 否则 put, 再返回 value\n    map.putIfAbsent(i, "val" + i);\n}\n\n// forEach 可以很方便地对 map 进行遍历操作\nmap.forEach((key, value) -> System.out.println(value));\n')])])]),t("p",[e._v("除了上面的 "),t("code",[e._v("putIfAbsent()")]),e._v(" 和 "),t("code",[e._v("forEach()")]),e._v(" 外，我们还可以很方便地对某个 "),t("code",[e._v("key")]),e._v(" 的值做相关操作：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// computeIfPresent(), 当 key 存在时，才会做相关处理\n// 如下：对 key 为 3 的值，内部会先判断值是否存在，存在，则做 value + key 的拼接操作\nmap.computeIfPresent(3, (num, val) -> val + num);\nmap.get(3);             // val33\n\n// 先判断 key 为 9 的元素是否存在，存在，则做删除操作\nmap.computeIfPresent(9, (num, val) -> null);\nmap.containsKey(9);     // false\n\n// computeIfAbsent(), 当 key 不存在时，才会做相关处理\n// 如下：先判断 key 为 23 的元素是否存在，不存在，则添加\nmap.computeIfAbsent(23, num -> "val" + num);\nmap.containsKey(23);    // true\n\n// 先判断 key 为 3 的元素是否存在，存在，则不做任何处理\nmap.computeIfAbsent(3, num -> "bam");\nmap.get(3);             // val33\n')])])]),t("p",[e._v("关于删除操作，JDK 8 中提供了能够新的 "),t("code",[e._v("remove()")]),e._v(" API:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('map.remove(3, "val3");\nmap.get(3);             // val33\n\nmap.remove(3, "val33");\nmap.get(3);             // null\n')])])]),t("p",[e._v("如上代码，只有当给定的 "),t("code",[e._v("key")]),e._v(" 和 "),t("code",[e._v("value")]),e._v(" 完全匹配时，才会执行删除操作。")]),e._v(" "),t("p",[e._v("关于添加方法，JDK 8 中提供了带有默认值的 "),t("code",[e._v("getOrDefault()")]),e._v(" 方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 若 key 42 不存在，则返回 not found\nmap.getOrDefault(42, "not found");  // not found\n')])])]),t("p",[e._v("对于 "),t("code",[e._v("value")]),e._v(" 的合并操作也变得更加简单：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// merge 方法，会先判断进行合并的 key 是否存在，不存在，则会添加元素\nmap.merge(9, "val9", (value, newValue) -> value.concat(newValue));\nmap.get(9);             // val9\n\n// 若 key 的元素存在，则对 value 执行拼接操作\nmap.merge(9, "concat", (value, newValue) -> value.concat(newValue));\nmap.get(9);             // val9concat\n')])])]),t("h2",{attrs:{id:"新的日期-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新的日期-api"}},[e._v("#")]),e._v(" 新的日期 API")]),e._v(" "),t("p",[e._v("Java 8 中在包 "),t("code",[e._v("java.time")]),e._v(" 下添加了新的日期 API. 它和 "),t("a",{attrs:{href:"http://www.joda.org/joda-time/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Joda-Time"),t("OutboundLink")],1),e._v(" 库相似，但又不完全相同。接下来，我会通过一些示例代码介绍一下新 API 中 最关键的特性：")]),e._v(" "),t("h3",{attrs:{id:"clock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#clock"}},[e._v("#")]),e._v(" Clock")]),e._v(" "),t("p",[t("code",[e._v("Clock")]),e._v(" 提供对当前日期和时间的访问。我们可以利用它来替代 "),t("code",[e._v("System.currentTimeMillis()")]),e._v(" 方法。另外，通过 "),t("code",[e._v("clock.instant()")]),e._v(" 能够获取一个 "),t("code",[e._v("instant")]),e._v(" 实例， 此实例能够方便地转换成老版本中的 "),t("code",[e._v("java.util.Date")]),e._v(" 对象。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Clock clock = Clock.systemDefaultZone();\nlong millis = clock.millis();\n\nInstant instant = clock.instant();\nDate legacyDate = Date.from(instant);   // 老版本 java.util.Date\n")])])]),t("h3",{attrs:{id:"timezones-时区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#timezones-时区"}},[e._v("#")]),e._v(" Timezones 时区")]),e._v(" "),t("p",[t("code",[e._v("ZoneId")]),e._v(" 代表时区类。通过静态工厂方法方便地获取它，入参我们可以传入某个时区编码。另外，时区类还定义了一个偏移量，用来在当前时刻或某时间 与目标时区时间之间进行转换。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('System.out.println(ZoneId.getAvailableZoneIds());\n// prints all available timezone ids\n\nZoneId zone1 = ZoneId.of("Europe/Berlin");\nZoneId zone2 = ZoneId.of("Brazil/East");\nSystem.out.println(zone1.getRules());\nSystem.out.println(zone2.getRules());\n\n// ZoneRules[currentStandardOffset=+01:00]\n// ZoneRules[currentStandardOffset=-03:00]\n')])])]),t("h3",{attrs:{id:"localtime"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#localtime"}},[e._v("#")]),e._v(" LocalTime")]),e._v(" "),t("p",[t("code",[e._v("LocalTime")]),e._v(" 表示一个没有指定时区的时间类，例如，"),t("code",[e._v("10 p.m")]),e._v(".或者 "),t("code",[e._v("17：30:15")]),e._v("，下面示例代码中，将会使用上面创建的 时区对象创建两个 "),t("code",[e._v("LocalTime")]),e._v("。然后我们会比较两个时间，并计算它们之间的小时和分钟的不同。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("LocalTime now1 = LocalTime.now(zone1);\nLocalTime now2 = LocalTime.now(zone2);\n\nSystem.out.println(now1.isBefore(now2));  // false\n\nlong hoursBetween = ChronoUnit.HOURS.between(now1, now2);\nlong minutesBetween = ChronoUnit.MINUTES.between(now1, now2);\n\nSystem.out.println(hoursBetween);       // -3\nSystem.out.println(minutesBetween);     // -239\n")])])]),t("p",[t("code",[e._v("LocalTime")]),e._v(" 提供多个静态工厂方法，目的是为了简化对时间对象实例的创建和操作，包括对时间字符串进行解析的操作等。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('LocalTime late = LocalTime.of(23, 59, 59);\nSystem.out.println(late);       // 23:59:59\n\nDateTimeFormatter germanFormatter =\n    DateTimeFormatter\n        .ofLocalizedTime(FormatStyle.SHORT)\n        .withLocale(Locale.GERMAN);\n\nLocalTime leetTime = LocalTime.parse("13:37", germanFormatter);\nSystem.out.println(leetTime);   // 13:37\n')])])]),t("h2",{attrs:{id:"localdate"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#localdate"}},[e._v("#")]),e._v(" LocalDate")]),e._v(" "),t("p",[t("code",[e._v("LocalDate")]),e._v(" 是一个日期对象，例如："),t("code",[e._v("2014-03-11")]),e._v("。它和 "),t("code",[e._v("LocalTime")]),e._v(" 一样是个 "),t("code",[e._v("final")]),e._v(" 类型对象。下面的例子演示了如何通过加减日，月，年等来计算一个新的日期。")]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("LocalDate")]),e._v(", "),t("code",[e._v("LocalTime")]),e._v(", 因为是 "),t("code",[e._v("final")]),e._v(" 类型的对象，每一次操作都会返回一个新的时间对象。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("LocalDate today = LocalDate.now();\n// 今天加一天\nLocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);\n// 明天减两天\nLocalDate yesterday = tomorrow.minusDays(2);\n\n// 2014 年七月的第四天\nLocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);\nDayOfWeek dayOfWeek = independenceDay.getDayOfWeek();\nSystem.out.println(dayOfWeek);    // 星期五\n")])])]),t("p",[e._v("也可以直接解析日期字符串，生成 "),t("code",[e._v("LocalDate")]),e._v(" 实例。（和 "),t("code",[e._v("LocalTime")]),e._v(" 操作一样简单）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('DateTimeFormatter germanFormatter =\n    DateTimeFormatter\n        .ofLocalizedDate(FormatStyle.MEDIUM)\n        .withLocale(Locale.GERMAN);\n\nLocalDate xmas = LocalDate.parse("24.12.2014", germanFormatter);\nSystem.out.println(xmas);   // 2014-12-24\n')])])]),t("h3",{attrs:{id:"localdatetime"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#localdatetime"}},[e._v("#")]),e._v(" LocalDateTime")]),e._v(" "),t("p",[t("code",[e._v("LocalDateTime")]),e._v(" 是一个"),t("strong",[e._v("日期-时间")]),e._v("对象。你也可以将其看成是 "),t("code",[e._v("LocalDate")]),e._v(" 和 "),t("code",[e._v("LocalTime")]),e._v(" 的结合体。操作上，也大致相同。")]),e._v(" "),t("blockquote",[t("p",[t("code",[e._v("LocalDateTime")]),e._v(" 同样是一个 "),t("code",[e._v("final")]),e._v(" 类型对象。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);\n\nDayOfWeek dayOfWeek = sylvester.getDayOfWeek();\nSystem.out.println(dayOfWeek);      // 星期三\n\nMonth month = sylvester.getMonth();\nSystem.out.println(month);          // 十二月\n\n// 获取改时间是该天中的第几分钟\nlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);\nSystem.out.println(minuteOfDay);    // 1439\n")])])]),t("p",[e._v("如果再加上的时区信息，"),t("code",[e._v("LocalDateTime")]),e._v(" 还能够被转换成 "),t("code",[e._v("Instance")]),e._v(" 实例。"),t("code",[e._v("Instance")]),e._v(" 能够被转换成老版本中 "),t("code",[e._v("java.util.Date")]),e._v(" 对象。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Instant instant = sylvester\n        .atZone(ZoneId.systemDefault())\n        .toInstant();\n\nDate legacyDate = Date.from(instant);\nSystem.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014\n")])])]),t("p",[e._v("格式化 "),t("code",[e._v("LocalDateTime")]),e._v(" 对象就和格式化 LocalDate 或者 LocalTime 一样。除了使用预定义的格式以外，也可以自定义格式化输出。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('DateTimeFormatter formatter =\n    DateTimeFormatter\n        .ofPattern("MMM dd, yyyy - HH:mm");\n\nLocalDateTime parsed = LocalDateTime.parse("Nov 03, 2014 - 07:13", formatter);\nString string = formatter.format(parsed);\nSystem.out.println(string);     // Nov 03, 2014 - 07:13\n')])])]),t("blockquote",[t("p",[e._v("注意：和 "),t("code",[e._v("java.text.NumberFormat")]),e._v(" 不同，新的 "),t("code",[e._v("DateTimeFormatter")]),e._v(" 类是 "),t("code",[e._v("final")]),e._v(" 类型的，同时也是线程安全的。更多细节请查看"),t("a",{attrs:{href:"http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),t("OutboundLink")],1)])]),e._v(" "),t("h2",{attrs:{id:"annotations-注解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#annotations-注解"}},[e._v("#")]),e._v(" Annotations 注解")]),e._v(" "),t("p",[e._v("在 Java 8 中，注解是可以重复的。让我通过下面的示例代码，来看看到底是咋回事。")]),e._v(" "),t("p",[e._v("首先，我们定义一个包装注解，里面包含了一个有着实际注解的数组：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("@interface Hints {\n    Hint[] value();\n}\n\n@Repeatable(Hints.class)\n@interface Hint {\n    String value();\n}\n")])])]),t("p",[e._v("Java 8 中，通过 "),t("code",[e._v("@Repeatable")]),e._v("，允许我们对同一个类使用多重注解：")]),e._v(" "),t("p",[e._v("第一种形态：使用注解容器（老方法）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('@Hints({@Hint("hint1"), @Hint("hint2")})\nclass Person {}\n')])])]),t("p",[e._v("第二种形态：使用可重复注解（新方法）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('@Hint("hint1")\n@Hint("hint2")\nclass Person {}\n')])])]),t("p",[e._v("使用第二种形态，Java 编译器能够在内部自动对 "),t("code",[e._v("@Hint")]),e._v(" 进行设置。这对于需要通过反射来读取注解信息时，是非常重要的。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Hint hint = Person.class.getAnnotation(Hint.class);\nSystem.out.println(hint);                   // null\n\nHints hints1 = Person.class.getAnnotation(Hints.class);\nSystem.out.println(hints1.value().length);  // 2\n\nHint[] hints2 = Person.class.getAnnotationsByType(Hint.class);\nSystem.out.println(hints2.length);          // 2\n")])])]),t("p",[e._v("尽管我们绝对不会在 "),t("code",[e._v("Person")]),e._v(" 类上声明 "),t("code",[e._v("@Hints")]),e._v(" 注解，但是它的信息仍然是可以通过 "),t("code",[e._v("getAnnotation(Hints.class)")]),e._v(" 来读取的。 并且，"),t("code",[e._v("getAnnotationsByType")]),e._v(" 方法会更方便，因为它赋予了所有 "),t("code",[e._v("@Hints")]),e._v(" 注解标注的方法直接的访问权限。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})\n@interface MyAnnotation {}\n")])])]),t("h2",{attrs:{id:"结语"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[e._v("#")]),e._v(" 结语")]),e._v(" "),t("p",[e._v("Java 8 新特性的编程指南到此就告一段落了。当然，还有很多内容需要进一步研究和说明。这就需要靠读者您来对 JDK 8 进一步探究了， 例如："),t("code",[e._v("Arrays.parallelSort")]),e._v(", "),t("code",[e._v("StampedLock")]),e._v(" 和 "),t("code",[e._v("CompletableFuture")]),e._v(" 等等，我这里也仅是起到抛砖引玉的作用而已。")]),e._v(" "),t("p",[e._v("最后，我希望这个教程能够对您有所帮助，也希望您阅读愉快。")]),e._v(" "),t("h2",{attrs:{id:"java8-相关拓展博文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java8-相关拓展博文"}},[e._v("#")]),e._v(" Java8 相关拓展博文")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c41d8ae6fb9a049a42f575b",target:"_blank",rel:"noopener noreferrer"}},[e._v("如何在 Java8 中风骚走位避开空指针异常"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://juejin.im/post/5c4568f8518825254c31b30d",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java8 新特性并发篇(一) | 线程与执行器"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);